# handlers/conversation.py

from telegram import Update, InlineKeyboardMarkup,InlineKeyboardButton,ReplyKeyboardRemove,WebAppInfo
from telegram.ext import ContextTypes, ConversationHandler,ConversationHandler
import psycopg2
import telegram.error
from datetime import datetime
import json
import traceback 
import logging
logger = logging.getLogger("AlertasTempranasBot")
from .utils import(
    
     merge_keyboard_with_navigation, crear_botones_navegacion,obtener_conexion_db,guardar_en_historial,verificar_modificacion,
    opciones_evento_verde_operacional,opciones_evento_verde_comunicacional,opciones_evento_critico,construir_resumen_parcial,
    actualizar_resumen_estatico,generar_numero_reporte,construir_resumen_parcial,crear_botones_navegacion,
    borrar_pregunta_anterior,eliminar_estado_del_historial,manejar_post_modificacion   
     )


# --- IMPORTS DE M√ìDULOS REORGANIZADOS ---
from configuracion.constantes import (
    ESTADO_CEDULA,ESTADO_NIVEL, ESTADO_TIPO_REPORTE, ESTADO_VERDE_OP_DESC, ESTADO_VERDE_OP_ACCIONES,
    ESTADO_VERIFICADO,ESTADO_OBSERVACIONES,ESTADO_ESPERANDO_MULTIMEDIA,ESTADO_VIOLENCIA,ESTADO_TIPO_EVENTO_TEXTO_ROJA,
    ESTADO_TIPO_EVENTO,ESTADO_TIPO_EVENTO_COMUNICACIONAL,ESTADO_DESCRIPCION_COMUNICACIONAL, ESTADO_TIPO_MEDIO,
    ESTADO_DESCRIPCION, ESTADO_ACCIONES,ESTADO_RECURSOS,ESTADO_MEDIO_ESPECIFICO,ESTADO_CONTENIDO_DIFUNDIDO,ESTADO_AUDIENCIA_AFECTADA,
    ESTADO_AMENAZA,ESTADO_REINICIAR,ESTADO_ESPERANDO_FECHA_HORA,ESTADO_ACTORES_CLAVE,ESTADO_FECHA_PUBLICACION,ESTADO_RESUMEN,ESTADO_ACTORES_CLAVE,ESTADO_CONFIRMACION_MODIFICACION     


)




#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< INICIO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia la conversaci√≥n y pide la c√©dula."""
    
    user = update.effective_user
    
    # 1. Guarda el nombre de usuario TEMPORALMENTE antes de limpiar
    user_name = user.full_name or user.username or "Usuario Desconocido"
    
    # 2. Reinicia los datos de la sesi√≥n anterior
    # Si esta l√≠nea se ejecuta, BORRA cualquier dato guardado anteriormente.
    context.user_data.clear()

# 3. Vuelve a guardar el nombre de usuario, asegurando que est√© disponible para la nueva sesi√≥n
    # ‚ùå ESTA L√çNEA ES CR√çTICA Y DEBE EJECUTARSE DESPU√âS DEL CLEAR
    context.user_data["nombre_usuario"] = user_name

    welcome_message = "Bienvenido al sistema automatizado de Reportes de alertas tempranas de FONPESCA. Este canal es exclusivo para personal autorizado.\n\nPor favor, ingresa su n√∫mero de c√©dula para continuar."
    if update.message:
        await update.message.reply_text(welcome_message)
    elif update.callback_query:
        await update.callback_query.edit_message_text(welcome_message)

    return ESTADO_CEDULA

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CEDULA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_cedula(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la c√©dula y pide el nivel de reporte, previa autenticaci√≥n."""
    cedula_input = update.message.text

       # 1. Guarda el estado actual en el historial antes de avanzar
    
    guardar_en_historial(context, ESTADO_CEDULA)
    
    # Creamos el keyboard de reintento para ambos casos de error
    keyboard = [[InlineKeyboardButton("üîÑ Intentar de nuevo", callback_data="reintentar_cedula")]]
    reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

    # Valida que la c√©dula sea un n√∫mero
    if not cedula_input.isdigit():
        await update.message.reply_text("‚ùå ¬°C√©dula inv√°lida, ingresa solo n√∫meros!\n\nPor favor, ingresa nuevamente su n√∫mero de c√©dula para continuar. ")

        return ESTADO_CEDULA # Se mantiene en el mismo estado para que pueda reintentar
    
    # Autenticaci√≥n basada en la c√©dula, consultando la base de datos
    conn = obtener_conexion_db()
    nombre_usuario = None  # Inicializamos a None
    
    if conn:
        try:
            with conn.cursor() as cursor:
                # Consulta para verificar la c√©dula
                query = "SELECT nombre, estado FROM usuarios WHERE cedula = %s;"
                cursor.execute(query, (cedula_input,))
                result = cursor.fetchone()
                
                if result:
                    nombre_usuario = result[0]
                    estado = result[1]

                else:
                    await update.message.reply_text("‚ùå Acceso denegado. La c√©dula ingresada no est√° autorizada. \n\n Presione cualquier tecla o n√∫mero para iniciar de nuevo.")
                    context.user_data.clear() # Limpia los datos de la conversaci√≥n
                    conn.close()
                    return ConversationHandler.END # Opcional: Se podr√≠a enviar a un estado de reintento
        except psycopg2.Error as err:
            logger.error(f"Error al verificar la c√©dula en la base de datos: {err}")
            await update.message.reply_text("Ocurri√≥ un error al verificar tu c√©dula. Por favor, int√©ntalo de nuevo m√°s tarde.")
            context.user_data.clear()
            if conn:
                conn.close()
            return ConversationHandler.END
        finally:
            if conn:
                conn.close()
    
    context.user_data["estado"] = estado  # si lo tienes en la tabla
    # Si la autenticaci√≥n es exitosa, se guarda la c√©dula y se contin√∫a
    if nombre_usuario:
        context.user_data["cedula"] = cedula_input
        personalized_welcome = f"¬°Hola, {nombre_usuario}! Autenticaci√≥n exitosa. ¬øQu√© nivel tiene el reporte?"
        
        
        reply_markup_nivel = InlineKeyboardMarkup(
         merge_keyboard_with_navigation([

            [InlineKeyboardButton("üü¢ Verde", callback_data="Verde")],
            [InlineKeyboardButton("üü° Amarilla", callback_data="Amarilla")],
            [InlineKeyboardButton("üü† Naranja", callback_data="Naranja")],
            [InlineKeyboardButton("üö® Roja", callback_data="Roja")],
        ])
        )
        
        await update.message.reply_text(personalized_welcome, reply_markup=reply_markup_nivel)

        return ESTADO_NIVEL
    else:
        # Esto se ejecuta si la c√©dula no se encuentra y el flujo no termin√≥ antes.
        # En el caso de c√©dula inv√°lida, el bot ya se queda en ESTADO_CEDULA y vuelve a pedirla.
        # Este else maneja el caso de que la c√©dula no est√© en la base de datos
        await update.message.reply_text("‚ùå Acceso denegado. La c√©dula ingresada no est√° autorizada.")
        return ConversationHandler.END

async def reintentar_cedula(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el bot√≥n de reintentar y reinicia la conversaci√≥n."""
    query = update.callback_query
    await query.answer()


    context.user_data.clear()
    
    await query.message.reply_text("Ingrese nuevamente la c√©dula ")

    return ESTADO_CEDULA

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MANEJAR NIVEL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


async def manejar_nivel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    
    query = update.callback_query
    await query.answer()


    
    context.user_data['nivel'] = query.data.title()
# <<<<<<<<<<<<<<<< BLOQUE GUARDAR MODIFICADO>>>>>>>>>>>>>>>>>
    modificacion = await verificar_modificacion(update, context)
    if modificacion:
        return modificacion
# <<<<<<<<<<<<<<<< FIN DEL  BLOQUE GUARDAR MODIFICADO >>>>>>>>>>>>>>>>>

# Mostrar resumen inicial solo una vez
    if "resumen_id" not in context.user_data:
        resumen = construir_resumen_parcial(context)
        mensaje_resumen = await query.message.reply_text(resumen, parse_mode="HTML")
        context.user_data["resumen_id"] = mensaje_resumen.message_id

    # eliminar_mensaje_anterior

    await borrar_pregunta_anterior(context, update)
 #  Guarda el estado actual en el historial antes de avanzar
    guardar_en_historial(context, ESTADO_NIVEL)
    

   # El teclado de Tipo de Reporte
    keyboard = [
        [InlineKeyboardButton("1. Operacional", callback_data="operacional")],
        [InlineKeyboardButton("2. Comunicacional", callback_data="comunicacional")]
    ]
    
    # 2. Fusionar el teclado con los botones de navegaci√≥n
    reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard)) # <-- MODIFICADO
    
    # ‚úÖ Eliminar el mensaje de selecci√≥n de nivel
    try:
        if query.message:
            await context.bot.delete_message(chat_id=query.message.chat_id, message_id=query.message.message_id)
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo borrar el mensaje de nivel: {e}")
        
    await update.callback_query.message.reply_text(
        " Porfavor, Selecciona el **Tipo de Reporte**:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )


    return ESTADO_TIPO_REPORTE

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_TIPO_REPORTE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


async def manejar_tipo_reporte(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()


    context.user_data["tipo_reporte"] = query.data.lower()

# Actualizar resumen
    await actualizar_resumen_estatico(update, context)

   # eliminar_mensaje_anterior

    await borrar_pregunta_anterior(context, update)
# 4. guardar_en_historial
    guardar_en_historial(context, ESTADO_TIPO_REPORTE)
    
    nivel = context.user_data.get("nivel", "").lower()
    tipo = context.user_data.get("tipo_reporte", "").lower()

    # 1. BIFURCACI√ìN CLAVE SEG√öN EL TIPO DE REPORTE
    if tipo == "comunicacional":
        
        if nivel == "verde":
           opciones = opciones_evento_verde_comunicacional
        else:
            opciones = opciones_evento_critico  # para amarilla, naranja, roja

        mensaje_pregunta = await query.message.reply_text(
        "üìå Por favor, selecciona el **tipo de evento comunicacional** que deseas reportar:",
        reply_markup=InlineKeyboardMarkup(merge_keyboard_with_navigation(opciones)),
        parse_mode='Markdown'
         )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id
        eliminar_estado_del_historial(context, ESTADO_TIPO_REPORTE)

        return ESTADO_TIPO_EVENTO_COMUNICACIONAL

    elif tipo == "operacional":
        
        # Flujo Operacional o Roja:
        # ‚úÖ CORRECCI√ìN SINT√ÅCTICA: Se eliminan los par√©ntesis ()
        if nivel == "verde":
            opciones = opciones_evento_verde_operacional
        else:
            opciones = opciones_evento_critico
            
        siguiente_estado = ESTADO_TIPO_EVENTO 

        mensaje_pregunta = await query.message.reply_text(
            "üìå Por favor, selecciona el **tipo de evento operacional** que deseas reportar:",
            reply_markup=InlineKeyboardMarkup(merge_keyboard_with_navigation(opciones)),
            parse_mode='Markdown'
        )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id
        return siguiente_estado
    
    # Manejo de casos no esperados
    return ConversationHandler.END

    
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_TIPO_EVENTO_COMUNICACIONAL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_tipo_evento_comunicacional(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el tipo de evento comunicacional."""

    # üîç Detectar si viene de modificaci√≥n (SETUP)
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("tipo_evento", None)  # üî• Eliminar respuesta anterior
        context.user_data['campo_a_modificar'] = 'tipo_evento' 

    # üîÑ Capturar dato seg√∫n origen
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        # Nota: Se capitaliza y reemplaza '_' por ' ' si viene de un CallbackQuery
        context.user_data["tipo_evento"] = query.data.replace("_", " ").capitalize()
        mensaje_respuesta = query.message
    else:
        mensaje_respuesta = update.message
        context.user_data["tipo_evento"] = update.message.text.strip()

    # üìã Actualizar resumen y limpiar pregunta anterior (necesario para ambos flujos)
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)
    
    if context.user_data.get("en_modo_modificacion"):
            
            # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
            if update.message:
                try:
                    await update.message.delete()
                except Exception as e:
                    # Si esto falla, verifica los permisos del bot en el chat.
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
                    
            # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
            return await manejar_post_modificacion(update, context)
        
    else:
            # ‚û°Ô∏è Flujo NORMAL:
            
            # 5a. Guardar en historial (para el bot√≥n 'Volver')
            guardar_en_historial(context, ESTADO_TIPO_EVENTO_COMUNICACIONAL)
        
        # 2. üìù Pregunta siguiente: descripci√≥n del evento
            mensaje_pregunta = await mensaje_respuesta.reply_text(
                "Por favor, ingresa la descripci√≥n del evento:",
                reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
            )
            context.user_data["pregunta_id"] = mensaje_pregunta.message_id

            # 3. Retornar el siguiente estado del flujo normal
            return ESTADO_DESCRIPCION_COMUNICACIONAL


#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_TIPO_EVENTO_TEXTO_ROJA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_tipo_evento_texto_roja(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el tipo de evento para alerta roja (texto libre)."""

    # üîê 1. Detectar y configurar modo modificaci√≥n si aplica (SETUP)
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("tipo_evento", None)  # Eliminar respuesta anterior
        context.user_data['campo_a_modificar'] = 'tipo_evento' 

    # üìù 2. Capturar texto (Aplica a ambos flujos)
    texto = update.message.text.strip()
    context.user_data["tipo_evento"] = texto

    # ‚úÖ 3. Verificar modificaci√≥n desde resumen (INTERRUPCI√ìN por navegaci√≥n)
    modificacion = await verificar_modificacion(update, context)
    if modificacion:
        # Se elimina el estado del historial si es una navegaci√≥n que interrumpe el flujo de entrada
        eliminar_estado_del_historial(context, ESTADO_TIPO_EVENTO_TEXTO_ROJA)
        return modificacion

    # üìã 4. Actualizar resumen y limpiar pregunta anterior (Aplica a ambos flujos)
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        # ‚úÖ Flujo de MODIFICACI√ìN:
        # Se captur√≥ el dato. Se llama al post-manejador para limpiar banderas 
        # y pedir la confirmaci√≥n de la modificaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        # 5a. Guardar el estado actual en el historial.
        guardar_en_historial(context, ESTADO_TIPO_EVENTO_TEXTO_ROJA)

        # 5b. üßæ Asignar valores predeterminados para alerta roja (para saltar pasos)
        context.user_data["descripcion_evento"] = "Alerta de m√°xima alerta"
        context.user_data["recursos_comprometidos"] = "No aplica"
        context.user_data["acciones_tomadas"] = "No aplica"
        context.user_data["observaciones"] = "Alerta de m√°xima alerta"
        
        # 5c. üìå Pregunta siguiente: violencia
        keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await update.message.reply_text("¬øHubo violencia?", reply_markup=reply_markup)

        # 5d. Retornar el siguiente estado
        return ESTADO_VIOLENCIA




#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_DESCRIPCION_COMUNICACIONAL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# handlers/conversacion.py

async def manejar_descripcion_comunicacional(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la descripci√≥n del evento comunicacional y pasa a la pregunta de Tipo de Medio (botones)."""
    
    # üìù 1. Capturar texto y guardar dato
    texto = update.message.text.strip()
    context.user_data["descripcion"] = texto
    
    # üîê 2. Flujo de Modificaci√≥n (Mantiene la l√≥gica de modificaci√≥n)
    if context.user_data.get("en_modo_modificacion") or context.user_data.get("pregunta_modificacion_id"):
        
        if update.message:
            try:
                await update.message.delete()
            except Exception:
                pass 

        context.user_data['campo_a_modificar'] = 'descripcion' 
        return await manejar_post_modificacion(update, context)
    
    # ‚û°Ô∏è 3. Flujo NORMAL (FIX: Env√≠a botones y retorna el estado)
    else:
        
        # 3.1. Guardar en historial
        guardar_en_historial(context, ESTADO_DESCRIPCION_COMUNICACIONAL)
        
        # 3.2. Limpieza y Actualizaci√≥n
        await actualizar_resumen_estatico(update, context)
        await borrar_pregunta_anterior(context, update) 

        
        # 5. Enviar la siguiente pregunta: TIPO DE MEDIO (Paso correcto para Comunicacional)
        
        keyboard = [
            [InlineKeyboardButton("Red Social", callback_data="red_social")],
            [InlineKeyboardButton("Prensa", callback_data="prensa")],
            [InlineKeyboardButton("Radio", callback_data="radio")],
            [InlineKeyboardButton("Televisi√≥n", callback_data="television")],
        ]
        
        mensaje = await update.message.reply_text(
            "üì° Por favor, selecciona el **Tipo de medio**:",
            reply_markup=InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard)),
            parse_mode='Markdown'
        )
        context.user_data["pregunta_id"] = mensaje.message_id
        
        # 6. Retornar el estado correcto
        # ‚úÖ CORRECCI√ìN CLAVE: Debe ser ESTADO_TIPO_MEDIO para seguir el flujo Comunicacional.
        return ESTADO_TIPO_MEDIO
 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_DESCRIPCION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_descripcion(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la descripci√≥n y salta la pregunta de recursos para la alerta Verde operacional."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("descripcion", None)
        context.user_data['campo_a_modificar'] = 'descripcion'

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["descripcion"] = texto
    context.user_data.setdefault("recursos_multimedia", [])


    # üîë Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN: Eliminar el mensaje actual del usuario
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")

        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL: (Tu c√≥digo original)
        guardar_en_historial(context, ESTADO_DESCRIPCION)
        return ESTADO_RECURSOS # o ESTADO_ACCIONES

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DESCRIPCION_EVENTO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_descripcion_evento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la descripci√≥n del evento y avanza a solicitar las acciones tomadas."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("descripcion_evento", None)
        context.user_data['campo_a_modificar'] = 'descripcion_evento'
    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["descripcion_evento"] = texto


    # üîë Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN: Eliminar el mensaje actual del usuario
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")

        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL: (Tu c√≥digo original)
        guardar_en_historial(context, ESTADO_DESCRIPCION)
        return await preguntar_fecha_webapp(update, context)
   
    

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_VERDE_OP_DESC >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#  ---
async def manejar_desc_verde_op(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Guarda la descripci√≥n del evento y pide las acciones tomadas (Verde Operacional)."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("descripcion_evento", None)
        context.user_data['campo_a_modificar'] = 'descripcion_evento'

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["descripcion_evento"] = texto

    # ... (omito verificacion y actualizacion de resumen, ya que estaban bien)

    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN: Eliminar el mensaje actual del usuario
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL: (Tu c√≥digo original)
        guardar_en_historial(context, ESTADO_VERDE_OP_DESC)
        # ... (c√≥digo para preguntar acciones tomadas)
        # ...
        return ESTADO_VERDE_OP_ACCIONES

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< manejar_tipo_medio >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


async def manejar_tipo_medio(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el tipo de medio y avanza al medio espec√≠fico."""

    query = update.callback_query
    await query.answer()

    # 1. Captura y doble asignaci√≥n (Tipo Evento/Medio)
    tipo_medio = query.data.replace("_", " ").capitalize()
    context.user_data["tipo_medio"] = tipo_medio
    context.user_data["tipo_evento"] = tipo_medio  

    # 2. Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update) 

    # üîê Flujo de Modificaci√≥n: SI estamos en modificaci√≥n, NO LLAMAMOS al post-manejador. 
    # Simplemente dejamos que el c√≥digo pase a la bifurcaci√≥n 3.3.
    if context.user_data.get("en_modo_modificacion") or context.user_data.get("pregunta_modificacion_id"):
        pass # ‚ö†Ô∏è Esto permite que el flujo contin√∫e al siguiente paso (Medio Espec√≠fico)
        
    # ‚û°Ô∏è Flujo Normal (Solo aqu√≠ guardamos historial)
    else:
        guardar_en_historial(context, ESTADO_TIPO_MEDIO)


    # 3.3. Bifurcaci√≥n para la siguiente pregunta (Medio Espec√≠fico) - L√ìGICA DE AVANCE
    tipo_medio_lower = tipo_medio.lower()
    
    if tipo_medio_lower == "red social":
        # ... (Opciones de Redes Sociales)
        opciones_redes = [
            [InlineKeyboardButton("WhatsApp", callback_data="WhatsApp")],
            [InlineKeyboardButton("Telegram", callback_data="Telegram")],
            [InlineKeyboardButton("Facebook", callback_data="Facebook")],
            [InlineKeyboardButton("Instagram", callback_data="Instagram")],
            [InlineKeyboardButton("TikTok", callback_data="TikTok")],
            [InlineKeyboardButton("YouTube", callback_data="YouTube")],
            [InlineKeyboardButton("X (Twitter)", callback_data="X")]
        ]
        
        mensaje = await query.message.reply_text(
            "üì± Por favor, selecciona la red social espec√≠fica:",
            reply_markup=InlineKeyboardMarkup(merge_keyboard_with_navigation(opciones_redes))
        )
        context.user_data["pregunta_id"] = mensaje.message_id
        return ESTADO_MEDIO_ESPECIFICO # <--- AVANZA
        
    else:
        # Pide texto para Prensa, TV, Otro
        mensaje = await query.message.reply_text(
            f"üì∞ Por favor, ingresa el nombre del medio espec√≠fico: (**{tipo_medio}**)",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion()),
            parse_mode="Markdown"
        )
        context.user_data["pregunta_id"] = mensaje.message_id
        eliminar_estado_del_historial(context, ESTADO_TIPO_MEDIO)
        return ESTADO_MEDIO_ESPECIFICO # <--- AVANZA
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_MEDIO_ESPECIFICO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


# Esta funci√≥n es el handler para ESTADO_MEDIO_ESPECIFICO
async def manejar_medio_especifico(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Maneja el nombre del medio espec√≠fico. Si es modificaci√≥n, finaliza el sub-flujo 
    y llama a manejar_post_modificacion.
    """
    
    # 1. Captura de dato (Maneja bot√≥n de Red Social o texto)
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        nombre_medio = query.data 
        mensaje_respuesta = query.message
        await borrar_pregunta_anterior(context, update)
    else:
        nombre_medio = update.message.text.strip()
        mensaje_respuesta = update.message

    context.user_data["nombre_medio"] = nombre_medio

    # 2. Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update) 

    # Si fue texto, borra el mensaje del usuario y la pregunta
    if update.message:
        await borrar_pregunta_anterior(context, update) 
        try:
            await update.message.delete()
        except Exception:
            pass
        
        # üîê CR√çTICO: Si estamos en modo modificaci√≥n, terminamos el proceso aqu√≠.
    if context.user_data.get("en_modo_modificacion") or context.user_data.get("pregunta_modificacion_id"):
            
        # Llama al post-manejador para enviar la pregunta de "Seguir editando / Continuar"
        return await manejar_post_modificacion(update, context)
    
    # ‚û°Ô∏è Flujo Normal
    else:
        # ... Flujo Normal: Guardar historial y avanzar al siguiente estado
        guardar_en_historial(context, ESTADO_MEDIO_ESPECIFICO)
        
        # Ejemplo: Pregunta siguiente (ajusta el estado)
        mensaje_pregunta = await mensaje_respuesta.reply_text(
            "üìù Por favor, ingrese el contenido difundido:",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
        )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id
        return ESTADO_CONTENIDO_DIFUNDIDO

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_CONTENIDO_DIFUNDIDO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_contenido_difundido(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el contenido difundido y omite las preguntas de violencia para la alerta Verde."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("contenido_difundido", None)
        context.user_data['campo_a_modificar'] = 'fecha_publicacion' 

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["contenido_difundido"] = texto

# üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    if context.user_data.get("en_modo_modificacion"):
            
            # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
            if update.message:
                try:
                    await update.message.delete()
                except Exception as e:
                    # Si esto falla, verifica los permisos del bot en el chat.
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
                    
            # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
            return await manejar_post_modificacion(update, context)
        
    else:
            # ‚û°Ô∏è Flujo NORMAL:
            
            # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_CONTENIDO_DIFUNDIDO)

    
        # üîÄ Flujo seg√∫n nivel
        nivel = context.user_data.get("nivel", "").lower()

        if nivel == "verde":
            context.user_data["audiencia_afectada"] = "No aplica (Alerta Verde)"
            context.user_data["violencia"] = "No"
            context.user_data["amenaza_vida"] = "No"

            keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
            reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

            await update.message.reply_text("¬øEl evento est√° verificado?", reply_markup=reply_markup)
            eliminar_estado_del_historial(context, ESTADO_CONTENIDO_DIFUNDIDO)
            return ESTADO_VERIFICADO
        else:
            mensaje = await update.message.reply_text(
                "Por favor, ingresa la audiencia afectada:",
                reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
            )
            context.user_data["pregunta_id"] = mensaje.message_id
            eliminar_estado_del_historial(context, ESTADO_CONTENIDO_DIFUNDIDO)
            return ESTADO_AUDIENCIA_AFECTADA
        
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_AUDIENCIA_AFECTADA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_audiencia_afectada(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la audiencia afectada y transita al estado compartido de violencia."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("audiencia_afectada", None)
        context.user_data['campo_a_modificar'] = 'audiencia_afectada' 

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["audiencia_afectada"] = texto

    
    nivel = context.user_data.get("nivel", "").lower()

    if nivel == "verde":
        # üü¢ Saltar violencia y amenaza
        context.user_data["violencia"] = "No"
        context.user_data["amenaza_vida"] = "No"

        keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await update.message.reply_text("¬øEl evento est√° verificado?", reply_markup=reply_markup)
        eliminar_estado_del_historial(context, ESTADO_AUDIENCIA_AFECTADA)
        return ESTADO_VERIFICADO
    else:
        # üü°üü†üî¥ Preguntar por violencia
        
        # üìã Actualizar resumen y limpiar pregunta anterior
        await actualizar_resumen_estatico(update, context)
        await borrar_pregunta_anterior(context, update)

        if context.user_data.get("en_modo_modificacion"):
                
                # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
                if update.message:
                    try:
                        await update.message.delete()
                    except Exception as e:
                        # Si esto falla, verifica los permisos del bot en el chat.
                        print(f"Error al intentar borrar el mensaje de usuario: {e}")
                        
                # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
                return await manejar_post_modificacion(update, context)
            
        else:
                # ‚û°Ô∏è Flujo NORMAL:
                
                # 5a. Guardar en historial (para el bot√≥n 'Volver')
            guardar_en_historial(context, ESTADO_AUDIENCIA_AFECTADA)

            keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
            reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

            await update.message.reply_text("¬øHubo violencia?", reply_markup=reply_markup)
            eliminar_estado_del_historial(context, ESTADO_AUDIENCIA_AFECTADA)
            return ESTADO_VIOLENCIA
        

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_VIOLENCIA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_violencia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la respuesta sobre la violencia."""

    query = update.callback_query
    await query.answer()

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("violencia", None)
        context.user_data['campo_a_modificar'] = 'violencia' 

    # üìù Capturar respuesta
    context.user_data["violencia"] = query.data.capitalize()


    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

     # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                # Si esto falla, verifica los permisos del bot en el chat.
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_VIOLENCIA)

        # ‚ò†Ô∏è Pregunta siguiente: amenaza a la vida
        keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await query.message.reply_text("¬øHubo amenaza a la vida?", reply_markup=reply_markup)
        eliminar_estado_del_historial(context, ESTADO_VIOLENCIA)
        return ESTADO_AMENAZA

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_AMENAZA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_amenaza(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la respuesta sobre amenaza a la vida y finaliza con la pregunta de verificaci√≥n."""

    query = update.callback_query
    await query.answer()

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("amenaza_vida", None)
        context.user_data['campo_a_modificar'] = 'amenaza_vida' 

    # üìù Capturar respuesta
    context.user_data["amenaza_vida"] = query.data


    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

     # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                # Si esto falla, verifica los permisos del bot en el chat.
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_AMENAZA)

        # üîç Pregunta siguiente: verificaci√≥n
        pregunta = "¬øEl evento est√° verificado?"
        keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await query.message.reply_text(pregunta, reply_markup=reply_markup)
        eliminar_estado_del_historial(context, ESTADO_AMENAZA)
        return ESTADO_VERIFICADO
        
 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_VERIFICADO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_verificado(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la respuesta de la verificaci√≥n y pasa a las observaciones."""

    query = update.callback_query
    await query.answer()

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("verificado", None)
        context.user_data['campo_a_modificar'] = 'verificado' 


    # üìù Capturar respuesta
    context.user_data["verificado"] = query.data


    # üìã Actualizar resumen y limpiar pregunta anterior
    await borrar_pregunta_anterior(context, update)
    await actualizar_resumen_estatico(update, context)

    

    
    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except Exception as e:
                # Si esto falla, verifica los permisos del bot en el chat.
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_VERIFICADO)

        # üìù Pregunta siguiente: observaciones
        pregunta = "Por favor, ingrese sus observaciones:"
        keyboard = [[InlineKeyboardButton("No tengo observaciones, continuar", callback_data="no_observaciones")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await query.message.reply_text(pregunta, reply_markup=reply_markup)

        eliminar_estado_del_historial(context, ESTADO_VERIFICADO)
        return ESTADO_OBSERVACIONES

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_OBSERVACIONES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_observaciones(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja las observaciones y pide multimedia."""
    
    # üîë 1. Detectar y configurar modo modificaci√≥n si aplica (SETUP)
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("observaciones", None)
        context.user_data['campo_a_modificar'] = 'observaciones' 

    # üîç 2. Capturar y guardar valor (Texto o Callback)
    observaciones = "Sin observaciones"
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        # Se asume que el √∫nico callback relevante aqu√≠ es "No tengo observaciones"
        # Si tienes otros callbacks, deber√°s manejarlos aqu√≠.
        
    elif update.message:
        texto = update.message.text.strip()
        observaciones = texto if texto else "Sin observaciones"
    
    # Guardar el valor capturado.
    context.user_data["observaciones"] = observaciones


    # üìã 4. Actualizar resumen y limpiar pregunta anterior (Borra la pregunta del BOT)
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (si es texto)
        if update.message:
            try:
                await update.message.delete()
            except telegram.error.BadRequest as e:
                # Ignorar espec√≠ficamente el error "Message to delete not found" (c√≥digo 400 Bad Request)
                if "message to delete not found" not in str(e).lower():
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_OBSERVACIONES)
        
        # 5b. üìé Pregunta siguiente: multimedia
        botones = [[InlineKeyboardButton("‚û°Ô∏è Continuar", callback_data="continuar_multimedia")]]
        # Se asume que merge_keyboard_with_navigation crea la botonera
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(botones)) 

        # NOTA: Usar update.effective_chat.send_message funciona tanto para update.message como para update.callback_query
        mensaje = await update.effective_chat.send_message(
            "üìé Por favor, adjunta hasta un m√°ximo de 5 archivos de im√°genes o videos. Si no tienes archivos, selecciona 'Continuar'.",
            reply_markup=reply_markup
        )

        context.user_data["pregunta_id"] = mensaje.message_id
        context.user_data.setdefault("recursos_multimedia", []) # Asegurar que el array existe

        return ESTADO_ESPERANDO_MULTIMEDIA


#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_ESPERANDO_MULTIMEDIA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

MAX_ARCHIVOS = 5

async def manejar_multimedia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la subida de archivos multimedia, documentos y audios."""

    mensaje = update.message
    if not mensaje:
        return ESTADO_ESPERANDO_MULTIMEDIA

    # üß∞ Asegura que el array exista
    recursos_list = context.user_data.setdefault("recursos_multimedia", [])

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data["campo_a_modificar"] = "recursos_multimedia"

        # üîÅ Reiniciar solo una vez
        if not context.user_data.get("modificacion_multimedia_iniciada"):
            context.user_data["recursos_multimedia"] = []
            recursos_list = context.user_data["recursos_multimedia"]
            context.user_data["modificacion_multimedia_iniciada"] = True

    # üìé Captura de archivo
    file_id = None
    if mensaje.photo:
        file_id = mensaje.photo[-1].file_id
    elif mensaje.video:
        file_id = mensaje.video.file_id
    elif mensaje.document:
        file_id = mensaje.document.file_id
    elif mensaje.audio:
        file_id = mensaje.audio.file_id
    else:
        await mensaje.reply_text("üö´ Por favor, env√≠a solo im√°genes, videos, documentos o audios.")
        return ESTADO_ESPERANDO_MULTIMEDIA

    # ‚úÖ Guardar archivo si no est√° duplicado
    if file_id not in recursos_list:
        recursos_list.append(file_id)

    total_actual = len(recursos_list)

    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    # ‚úÖ Construir mensaje din√°mico
    if total_actual >= MAX_ARCHIVOS:
        mensaje_respuesta = (
            f"üéâ **L√≠mite alcanzado.** Has adjuntado {MAX_ARCHIVOS} archivos.\n"
            "Presiona '‚û°Ô∏è Continuar' para guardar los cambios."
        )
    else:
        restantes = MAX_ARCHIVOS - total_actual
        plural = "archivo" if restantes == 1 else "archivos"
        mensaje_respuesta = (
            f"‚úÖ **Archivo recibido** ({total_actual}/{MAX_ARCHIVOS}). "
            f"Puedes adjuntar **{restantes}** {plural} m√°s, o presiona '‚û°Ô∏è Continuar' para guardar los cambios."
        )

    # üßæ Enviar mensaje
    await mensaje.reply_text(
        mensaje_respuesta,
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚û°Ô∏è Continuar", callback_data="continuar_multimedia")]
        ]),
        parse_mode="Markdown"
    )

    # üîÅ Flujo de modificaci√≥n: NO cerrar a√∫n, esperar bot√≥n
    if context.user_data.get("en_modo_modificacion"):
        return ESTADO_ESPERANDO_MULTIMEDIA

    # ‚û°Ô∏è Flujo normal
    guardar_en_historial(context, ESTADO_ESPERANDO_MULTIMEDIA)
    eliminar_estado_del_historial(context, ESTADO_ESPERANDO_MULTIMEDIA)
    return ESTADO_ESPERANDO_MULTIMEDIA

async def continuar_multimedia(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Finaliza la etapa multimedia y muestra el resumen final con opciones de env√≠o o modificaci√≥n."""

    query = update.callback_query
    await query.answer()

    # üö® FLUJO DE MODIFICACI√ìN
    if context.user_data.get("pregunta_modificacion_id") or context.user_data.get("en_modo_modificacion"):

        # 1. Borrar la pregunta del bot si existe
        pregunta_id = context.user_data.pop("pregunta_id", None)
        if pregunta_id:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=pregunta_id
                )
            except Exception:
                pass  # Ignorar errores de borrado

        # 2. Asegurar que la lista exista (aunque est√© vac√≠a)
        context.user_data.setdefault("recursos_multimedia", [])

        # 3. Limpiar bandera de reinicio de modificaci√≥n
        context.user_data.pop("modificacion_multimedia_iniciada", None)

        # 4. Actualizar resumen
        await actualizar_resumen_estatico(update, context)

        # 5. Fijar campo y redirigir al flujo de post-modificaci√≥n
        context.user_data["campo_a_modificar"] = "recursos_multimedia"
        return await manejar_post_modificacion(update, context)

    # ----------------------------------------------------
    # FLUJO NORMAL
    # ----------------------------------------------------

    # 1. Borrar mensajes anteriores del bot
    for key in ["pregunta_id", "resumen_id"]:
        mensaje_id = context.user_data.pop(key, None)
        if mensaje_id:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=mensaje_id
                )
            except Exception:
                pass

    # 2. Marcar etapa multimedia como finalizada
    context.user_data["multimedia_finalizada"] = True
    guardar_en_historial(context, ESTADO_ESPERANDO_MULTIMEDIA)
    await actualizar_resumen_estatico(update, context)

    # 3. Mostrar resumen final
    resumen_final = construir_resumen_parcial(context)
    mensaje_resumen = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"<b>FONPESCA - Sistema de Reportes de Alertas Tempranas</b>\n\n{resumen_final}",
        parse_mode="HTML"
    )
    context.user_data["resumen_id"] = mensaje_resumen.message_id

    # 4. Mostrar botones finales
    botones = [
        [InlineKeyboardButton("‚úÖ Enviar reporte", callback_data="enviar_reporte")],
        [InlineKeyboardButton("‚úèÔ∏è Modificar", callback_data="modificar_reporte")],
        [InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar_reporte")]
    ]
    reply_markup_final = InlineKeyboardMarkup(merge_keyboard_with_navigation(botones))

    mensaje_botones = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="¬øDesea enviar el reporte o realizar modificaciones?",
        reply_markup=reply_markup_final
    )
    context.user_data["mensaje_botones_finales_id"] = mensaje_botones.message_id

    # 5. Eliminar estado de resumen del historial
    try:
        eliminar_estado_del_historial(context, ESTADO_RESUMEN)
    except Exception:
        pass

    return ESTADO_RESUMEN
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_TIPO_EVENTO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_tipo_evento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja el tipo de evento para reportes operacionales (Verde, Amarillo, Naranja)."""
    
    # üö® NOTA: La l√≥gica de 'verificar_modificacion' al inicio ya maneja los casos iniciales.
    # Esta funci√≥n est√° m√°s dise√±ada para los handlers de texto.
    # La quitaremos para simplificar, confiando en que tu handler de 'ESTADO_MODIFICAR' la maneja.
    
    # üì• Determinar origen del mensaje
    message_to_reply = update.callback_query.message if update.callback_query else update.message

    # --- 1. L√≥gica cuando viene de BOT√ìN (callback_query) ---
    if update.callback_query:
        query = update.callback_query
        await query.answer()

        if query.data in ["otros", "otro_operacional"]:
            await message_to_reply.reply_text(
                "Por favor, describe manualmente el tipo de evento:",
                reply_markup=InlineKeyboardMarkup(merge_keyboard_with_navigation([]))
            )
            eliminar_estado_del_historial(context, ESTADO_TIPO_EVENTO)
            return ESTADO_TIPO_EVENTO # Vuelve a esperar la respuesta en el mismo estado

        context.user_data["tipo_evento"] = query.data.replace("_", " ").capitalize()
        
        # üîë CLAVE: Actualizar y luego decidir el flujo (Modificaci√≥n vs. Normal)

        await actualizar_resumen_estatico(update, context)
        await borrar_pregunta_anterior(context, update) # Borrar la pregunta del Tipo de Evento

        # >>> CORRECCI√ìN DE FLUJO CR√çTICA para botones <<<
        if context.user_data.get("en_modo_modificacion"):
            context.user_data['campo_a_modificar'] = 'tipo_evento' # Fija el campo
            return await manejar_post_modificacion(update, context)
        # >>> Fin CORRECCI√ìN DE FLUJO CR√çTICA <<<
        
        # Flujo Normal: Guardar en historial y avanzar
        guardar_en_historial(context, ESTADO_TIPO_EVENTO)

        # Pregunta siguiente: Descripci√≥n
        mensaje_pregunta = await message_to_reply.reply_text(
            "Por favor, ingresa la descripci√≥n del evento:",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
        )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id
        
        # El estado de destino depende del tipo de reporte para la siguiente pregunta
        destino = ESTADO_DESCRIPCION if context.user_data.get("tipo_reporte") == "operacional" else ESTADO_DESCRIPCION_COMUNICACIONAL
        return destino

    # --- 2. L√≥gica cuando viene de TEXTO LIBRE (respuesta de 'otros') ---
    elif update.message:
        context.user_data["tipo_evento"] = update.message.text.strip()
        
        # üîë CLAVE: Actualizar y luego decidir el flujo (Modificaci√≥n vs. Normal)
        await actualizar_resumen_estatico(update, context)
        await borrar_pregunta_anterior(context, update) # Borrar la pregunta del Tipo de Evento
        
        # >>> CORRECCI√ìN DE FLUJO CR√çTICA para texto libre <<<
        if context.user_data.get("en_modo_modificacion"):
            context.user_data['campo_a_modificar'] = 'tipo_evento' # Fija el campo
            return await manejar_post_modificacion(update, context)
        # >>> Fin CORRECCI√ìN DE FLUJO CR√çTICA <<<
        
        # Flujo Normal: Guardar en historial y avanzar
        guardar_en_historial(context, ESTADO_TIPO_EVENTO)
        
        # Pregunta siguiente: Descripci√≥n
        mensaje_pregunta = await update.message.reply_text(
            "Por favor, ingresa la *descripci√≥n del evento:*",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion()),
            parse_mode="Markdown"
        )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id
        
        # El estado de destino depende del tipo de reporte para la siguiente pregunta
        destino = ESTADO_DESCRIPCION if context.user_data.get("tipo_reporte") == "operacional" else ESTADO_DESCRIPCION_COMUNICACIONAL
        return destino
    
    # En caso de que no haya mensaje ni callback (ej: un error)
    return ConversationHandler.END

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_RECURSOS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


async def manejar_recursos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja los recursos comprometidos y avanza a las acciones tomadas."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("recursos", None)

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["recursos"] = texto

    
    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except telegram.error.BadRequest as e:
                # Ignorar espec√≠ficamente el error "Message to delete not found" (c√≥digo 400 Bad Request)
                if "message to delete not found" not in str(e).lower():
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:

        guardar_en_historial(context, ESTADO_RECURSOS)

        # üìù Pregunta siguiente: acciones tomadas
        mensaje_pregunta = await update.message.reply_text(
            "üìù Por favor, ingresa las **acciones tomadas**:",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion()),
            parse_mode='Markdown'
        )
        context.user_data["pregunta_id"] = mensaje_pregunta.message_id

        eliminar_estado_del_historial(context, ESTADO_RECURSOS)
        return ESTADO_ACCIONES


 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_ACCIONES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
async def manejar_acciones(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja las acciones tomadas y transita al estado de violencia o verificaci√≥n seg√∫n el nivel."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("acciones", None)
        context.user_data['campo_a_modificar'] = 'acciones' 

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["acciones"] = texto

    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

  

    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except telegram.error.BadRequest as e:
                # Ignorar espec√≠ficamente el error "Message to delete not found" (c√≥digo 400 Bad Request)
                if "message to delete not found" not in str(e).lower():
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_ACCIONES)

        # üîÄ Flujo seg√∫n nivel
        nivel = context.user_data.get("nivel", "").lower()

        keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        if nivel == "verde":
            context.user_data["violencia"] = "No"
            context.user_data["amenaza_vida"] = "No"
            await update.message.reply_text("¬øEl evento est√° verificado?", reply_markup=reply_markup)
            eliminar_estado_del_historial(context, ESTADO_ACCIONES)
            return ESTADO_VERIFICADO
        else:
            await update.message.reply_text("¬øHubo violencia?", reply_markup=reply_markup)
            eliminar_estado_del_historial(context, ESTADO_ACCIONES)
            return ESTADO_VIOLENCIA




 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ESTADO_ACCIONES_TOMADAS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_acciones_tomadas(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja las acciones tomadas y muestra la siguiente pregunta de verificaci√≥n."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("acciones_tomadas", None)
        context.user_data['campo_a_modificar'] = 'fecha_publicacion' 

    # üìù Capturar texto
    texto = update.message.text.strip()
    context.user_data["acciones_tomadas"] = texto

    # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    if context.user_data.get("en_modo_modificacion"):
            
            # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
            if update.message:
                try:
                    await update.message.delete()
                except Exception as e:
                    # Si esto falla, verifica los permisos del bot en el chat.
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
                    
            # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
            return await manejar_post_modificacion(update, context)
        
    else:
            # ‚û°Ô∏è Flujo NORMAL:
            
            # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_ACCIONES)

    # ‚úÖ Pregunta siguiente: verificaci√≥n
    mensaje_pregunta = await update.message.reply_text(
        "¬øEl evento est√° verificado?",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]
        ])
    )
    context.user_data["pregunta_id"] = mensaje_pregunta.message_id

    eliminar_estado_del_historial(context, ESTADO_ACCIONES)
    return ESTADO_VERIFICADO

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CONFIRMAR_Y_ENVIAR >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def confirmar_y_enviar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Confirma el env√≠o del reporte, muestra el resumen final y ofrece reiniciar."""

    query = update.callback_query
    await query.answer()

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True

    try:
        # üßπ Eliminar resumen anterior si existe
        resumen_id = context.user_data.pop("resumen_id", None)
        if resumen_id:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=resumen_id)

        # üßæ Generar n√∫mero de reporte y resumen
        numero_reporte = generar_numero_reporte(context)
        context.user_data["numero_reporte"] = numero_reporte

        from handlers.utils import construir_resumen_parcial
        resumen_final = construir_resumen_parcial(context)

        # ‚úÖ Enviar resumen final
        await query.message.reply_text(
            f"‚úÖ ¬°Reporte enviado exitosamente!\n\n"
            f"<b>N√∫mero de Reporte:</b> {numero_reporte}\n\n"
            f"{resumen_final}",
            parse_mode="HTML"
        )

        # üîÅ Preguntar si desea iniciar otro reporte
        keyboard = [
            [InlineKeyboardButton("‚úÖ S√≠", callback_data="si_otro_reporte")],
            [InlineKeyboardButton("‚ùå No", callback_data="no_otro_reporte")]
        ]
        reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="¬øDesea realizar otro reporte?",
            reply_markup=reply_markup
        )

    except Exception as e:
        import traceback
        logger.error(f"‚ùå Error al enviar el reporte: {e}\n{traceback.format_exc()}")
        await query.message.reply_text("‚ùå Ocurri√≥ un error al enviar el reporte. Por favor, intenta de nuevo.")

    return ESTADO_REINICIAR
 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CANCELAR >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela la conversaci√≥n y limpia el contexto."""

    # üßπ Mensaje de cierre
    await update.message.reply_text(
        "‚ùå Conversaci√≥n cancelada.\nPuedes iniciar un nuevo reporte en cualquier momento.",
        reply_markup=ReplyKeyboardRemove()
    )

    # üßº Limpieza completa del contexto
    context.user_data.clear()

    return ConversationHandler.END

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< manejar_verificacion_verde_op >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_verificacion_verde_op(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la verificaci√≥n del reporte de Alerta Verde Operacional y dirige a la etapa de multimedia/observaciones."""

    query = update.callback_query
    await query.answer()

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data['reporte'].pop("verificado", None)
        context.user_data['campo_a_modificar'] = 'verificado' 


    # üß≠ Guardar estado en historial si no est√° presente
    if "history_stack" not in context.user_data:
        context.user_data["history_stack"] = []
    if not context.user_data["history_stack"] or context.user_data["history_stack"][-1] != ESTADO_NIVEL:
        context.user_data["history_stack"].append(ESTADO_NIVEL)

    # üìù Capturar respuesta
    context.user_data["reporte"]["verificado"] = query.data
    logger.info(f"Reporte de {context.user_data['reporte']['nivel_alerta']} - Verificado: {query.data}")

    # üì¶ Solicitud de observaciones/multimedia
    keyboard = [[InlineKeyboardButton("‚úÖ Continuar sin multimedia", callback_data="continuar_sin_multimedia")]]
    reply_markup = InlineKeyboardMarkup(merge_keyboard_with_navigation(keyboard))

    await query.message.reply_text(
        "üìù **Observaciones / Multimedia Opcional:**\n\n"
        "Si desea a√±adir **observaciones** (texto), por favor escr√≠balas y env√≠elas ahora. Despu√©s podr√° adjuntar fotos, videos o documentos.\n\n"
        "Cuando est√© listo, pulse **'Continuar sin multimedia'** para ir al resumen, o simplemente env√≠e sus archivos.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

    eliminar_estado_del_historial(context, ESTADO_OBSERVACIONES)
    return ESTADO_ESPERANDO_MULTIMEDIA


 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< FECHA Y HORA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Mantendr√© el nombre de la funci√≥n que tienes para no romper tus referencias
async def manejar_webapp_fecha_hora(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recibe la fecha y hora desde el WebApp y la guarda en el contexto."""

    try:
        # üîê Activar modo modificaci√≥n si aplica
        if context.user_data.get("pregunta_modificacion_id"):
            context.user_data["en_modo_modificacion"] = True
            context.user_data.pop("fecha_publicacion", None)
            context.user_data.pop("hora_publicacion", None)

        # üì• Obtener datos del WebApp
        datos = update.message.web_app_data.data.strip()
        logger.info(f"Datos recibidos de WebApp: {datos}")

        partes = datos.split(" - ")
        if len(partes) == 2:
            fecha, hora = partes
        else:
            logger.warning(f"Formato de fecha/hora incorrecto: {datos}")
            fecha = datetime.now().strftime("%d %b %Y")
            hora = datetime.now().strftime("%I:%M %p")

        context.user_data["fecha_publicacion"] = fecha
        context.user_data["hora_publicacion"] = hora

        # üìã Actualizar resumen y limpiar pregunta anterior
        await actualizar_resumen_estatico(update, context)
        await borrar_pregunta_anterior(context, update)

        # üßº Guardar en historial solo si no es modificaci√≥n
        if not context.user_data.get("en_modo_modificacion"):
            guardar_en_historial(context, ESTADO_OBSERVACIONES)

        # üë• Pregunta siguiente: actores clave
        mensaje = await update.effective_chat.send_message(
            "üë• Por favor, ingresa los actores clave involucrados:",
            reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
        )
        context.user_data["pregunta_id"] = mensaje.message_id
        eliminar_estado_del_historial(context, ESTADO_OBSERVACIONES)

        return ESTADO_ACTORES_CLAVE

    except AttributeError:
        logger.error("WebApp cerr√≥ sin enviar datos o llegaron incompletos (AttributeError).")
        await update.effective_chat.send_message(
            "‚ö†Ô∏è No se recibi√≥ la fecha/hora. Por favor, aseg√∫rese de presionar 'Confirmar' e intente seleccionarla nuevamente."
        )
        eliminar_estado_del_historial(context, ESTADO_OBSERVACIONES)
        return ESTADO_FECHA_PUBLICACION

    except Exception as e:
        error_trace = traceback.format_exc()
        logger.error(f"Error inesperado al manejar datos de WebApp: {e}\n{error_trace}")
        await update.effective_chat.send_message(
            "‚ùå Ocurri√≥ un error inesperado al procesar la fecha. Intentaremos de nuevo."
        )
        eliminar_estado_del_historial(context, ESTADO_OBSERVACIONES)
        return ESTADO_FECHA_PUBLICACION

WEBAPP_FECHA_URL = "https://selector-fecha-hora-bot-rat.vercel.app/" 

def generar_teclado_fecha_publicacion() -> InlineKeyboardMarkup:
    """Genera el teclado con el bot√≥n que lanza la WebApp."""

    botones = [
        # 1. Bot√≥n de la WebApp. Usa el par√°metro 'web_app' y 'WebAppInfo'.
        [InlineKeyboardButton("üìÖ Seleccionar Fecha y Hora", web_app=WebAppInfo(url=WEBAPP_FECHA_URL))],
    ]
    
    # 2. Agregar navegaci√≥n si es necesario (asumo que tienes una funci√≥n para esto)
    # Ejemplo:
    # from .utils import crear_botones_navegacion 
    # botones.extend(crear_botones_navegacion()) 
    
    return InlineKeyboardMarkup(botones)


async def preguntar_fecha_webapp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Funci√≥n que lanza la pregunta al usuario."""
    
    # [Si el bot necesita borrar mensajes anteriores, col√≥calo aqu√≠]

    await update.effective_chat.send_message(
        "üóì Por favor, selecciona la fecha y hora de publicaci√≥n usando la herramienta:",
        reply_markup=generar_teclado_fecha_publicacion()
    )
    
    return ESTADO_FECHA_PUBLICACION # Mantiene el estado esperando la respuesta

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ACTORES CLAVES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def manejar_actores_clave(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja los actores clave y transita seg√∫n tipo y nivel de reporte."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("actores_clave", None)
        # CLAVE: Identificar el campo modificado para manejar_post_modificacion
        context.user_data['campo_a_modificar'] = 'actores_clave' 

    if update.message and update.message.text:
        
        # <--- APROXIMADAMENTE AQU√ç ESTABA LA L√çNEA 1659 ORIGINAL QUE FALLABA --->
        texto = update.message.text.strip() # Ahora es seguro usar .strip()
        
        # 1. Validaci√≥n de entrada de texto (Si la tienes)
        if len(texto) < 3: 
            await update.message.reply_text("El campo de actores clave es muy corto. Por favor, ingrese una descripci√≥n m√°s detallada.")
            return ESTADO_ACTORES_CLAVE

        # 2. Guardar datos
        context.user_data["actores_clave"] = texto

   # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)


    # üîë 5. Bifurcaci√≥n CLAVE: Flujo de Modificaci√≥n vs. Flujo Normal
    if context.user_data.get("en_modo_modificacion"):
        
        # üóëÔ∏è CORRECCI√ìN CR√çTICA: Eliminar el mensaje actual del usuario (SOLUCI√ìN DE LA PREGUNTA PERSISTENTE)
        if update.message:
            try:
                await update.message.delete()
            except telegram.error.BadRequest as e:
                # Ignorar espec√≠ficamente el error "Message to delete not found" (c√≥digo 400 Bad Request)
                if "message to delete not found" not in str(e).lower():
                    print(f"Error al intentar borrar el mensaje de usuario: {e}")
            except Exception as e:
                print(f"Error al intentar borrar el mensaje de usuario: {e}")
                
        # ‚úÖ Flujo de MODIFICACI√ìN: Llama al post-manejador para limpiar banderas y pedir la confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    
    else:
        # ‚û°Ô∏è Flujo NORMAL:
        
        # 5a. Guardar en historial (para el bot√≥n 'Volver')
        guardar_en_historial(context, ESTADO_ACTORES_CLAVE)
            
        # 5b. üîÄ Flujo seg√∫n tipo y nivel
        tipo = context.user_data.get("tipo_reporte", "").lower()
        nivel = context.user_data.get("nivel", "").lower()

        if tipo == "operacional":
            if nivel == "verde":
                mensaje = await update.message.reply_text(
                    "‚úÖ Por favor, ingresa las **acciones tomadas**:",
                    parse_mode='Markdown',
                    reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
                )
                context.user_data["pregunta_id"] = mensaje.message_id
                # El estado se guarda antes. Solo se retorna el nuevo estado.
                return ESTADO_ACCIONES

            elif nivel in ["amarilla", "naranja"]:
                mensaje = await update.message.reply_text(
                    "üì¶ Por favor, ingresa los **recursos comprometidos**:",
                    parse_mode='Markdown',
                    reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
                )
                context.user_data["pregunta_id"] = mensaje.message_id
                # El estado se guarda antes. Solo se retorna el nuevo estado.
                return ESTADO_RECURSOS

            elif nivel == "roja":
                keyboard = [[InlineKeyboardButton("‚úÖ S√≠", callback_data="si"), InlineKeyboardButton("‚ùå No", callback_data="no")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                mensaje = await update.message.reply_text("¬øHubo **violencia**?", parse_mode='Markdown', reply_markup=reply_markup)
                context.user_data["pregunta_id"] = mensaje.message_id
                # El estado se guarda antes. Solo se retorna el nuevo estado.
                return ESTADO_VIOLENCIA

        elif tipo == "comunicacional":
            mensaje = await update.message.reply_text(
                "üì∞ Por favor, ingresa el **contenido difundido**:",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
            )
            context.user_data["pregunta_id"] = mensaje.message_id
            # El estado se guarda antes. Solo se retorna el nuevo estado.
            return ESTADO_CONTENIDO_DIFUNDIDO

        # ‚ö†Ô∏è Fallback si no se reconoce el flujo
        await update.message.reply_text("‚ö†Ô∏è No se pudo determinar el flujo. Intenta de nuevo.")
        eliminar_estado_del_historial(context, ESTADO_ACTORES_CLAVE)
        return ESTADO_VERIFICADO
    

 #<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< fecha >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

async def preguntar_fecha_manual(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Solicita al usuario que ingrese manualmente la fecha y hora del evento."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("fecha_publicacion", None)
        context.user_data.pop("hora_publicacion", None)

    # üßπ Limpiar pregunta anterior y actualizar resumen
    await borrar_pregunta_anterior(context, update)
    await actualizar_resumen_estatico(update, context)

    # üóìÔ∏è Pregunta de fecha/hora
    mensaje = await update.effective_chat.send_message(
        "üóìÔ∏è *Por favor, escribe la fecha y hora del evento en este formato exacto:*\n\n"
        "`27/10/2025 11:00 AM`\n\n"
        "‚úÖ Aseg√∫rate de incluir el espacio entre la fecha y la hora, y usar AM o PM en may√∫sculas.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
    )
    context.user_data["pregunta_id"] = mensaje.message_id

    return ESTADO_FECHA_PUBLICACION

async def manejar_fecha_manual(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Procesa la fecha y hora ingresadas manualmente, y transita a actores clave."""

    # üîê Activar modo modificaci√≥n si aplica
    if context.user_data.get("pregunta_modificacion_id"):
        context.user_data["en_modo_modificacion"] = True
        context.user_data.pop("fecha_publicacion", None)
        context.user_data.pop("hora_publicacion", None)
        context.user_data['campo_a_modificar'] = 'fecha_publicacion' 
    # üìù Capturar texto
    texto = update.message.text.strip()

    try:
        fecha_hora = datetime.strptime(texto, "%d/%m/%Y %I:%M %p")
        context.user_data["fecha_publicacion"] = fecha_hora.strftime("%d/%m/%Y")
        context.user_data["hora_publicacion"] = fecha_hora.strftime("%I:%M %p")
    except ValueError:
        await update.message.reply_text(
            "‚ö†Ô∏è *Formato inv√°lido.* Por favor, usa este formato exacto:\n\n"
            "`27/10/2025 11:00 AM`\n\n"
            "Incluye el espacio entre fecha y hora, y usa AM o PM en may√∫sculas.",
            parse_mode="Markdown"
        )
        eliminar_estado_del_historial(context, ESTADO_FECHA_PUBLICACION)
        return ESTADO_FECHA_PUBLICACION

   # üìã Actualizar resumen y limpiar pregunta anterior
    await actualizar_resumen_estatico(update, context)
    await borrar_pregunta_anterior(context, update)

    # üîë CLAVE: La condici√≥n para evitar guardar el estado temporal y redirigir
    if context.user_data.get("en_modo_modificacion"):
        # Flujo de Modificaci√≥n: NO guarda en historial. 
        # Llama a la funci√≥n que limpia la bandera y pide confirmaci√≥n.
        return await manejar_post_modificacion(update, context)
    else:
        # Flujo Normal: Guarda en historial y avanza al siguiente estado (Actores Clave)
        guardar_en_historial(context, ESTADO_FECHA_PUBLICACION)
    
    # üë• Pregunta siguiente: actores clave
    mensaje = await update.message.reply_text(
        "üë• Por favor, ingrese los actores clave:",
        reply_markup=InlineKeyboardMarkup(crear_botones_navegacion())
    )
    context.user_data["pregunta_id"] = mensaje.message_id

    eliminar_estado_del_historial(context, ESTADO_FECHA_PUBLICACION)
    return ESTADO_ACTORES_CLAVE